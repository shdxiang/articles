%++++++++++++++++++++++++++++++++++++++++
% Don't modify this section unless you know what you're doing!
\documentclass{article}
\usepackage{amsmath} % improve math presentation
\usepackage{graphicx} % takes care of graphic including machinery
\usepackage[margin=1in,letterpaper]{geometry} % decreases margins
\usepackage{cite} % takes care of citations
\usepackage{url}
% \usepackage[utf8]{inputenc}
\usepackage[UTF8]{ctex} % 支持中文
\usepackage{listings}
%++++++++++++++++++++++++++++++++++++++++

\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}

\begin{document}

\title{比特币：一种点对点的电子货币系统}
\author{
 Satoshi Nakamoto\\
 satoshin@gmx.com\\
 www.bitcoin.org\\
}
\date{}

\maketitle

\begin{abstract}
 \noindent
 一种纯粹的 \textbf{点对点（peer-to-peer）}\ 电子货币应当支持在线支付从付款方直接发送到收款方，而不需金融机构的参与。\textbf{数字签名（digital signatures）}\ 提供了部分电子货币的解决方案，但如果仍需一个 \textbf{可信第三方（trusted third party）}\ 来防止 \textbf{双重支付（double-spending）}，那就失去了其主要优点。我们提出一种使用点对点网络解决 \textbf{双重支付}\ 问题的方案，该网络通过将交易 \textbf{哈希（hashing）}\ 进一条不断增长的基于哈希的 \textbf{工作量证明（proof-of-work）}\ 链来给交易打上时间戳，形成除非重做 \textbf{工作量证明}\ 所代表的工作否则不能更改的记录。最长的链不仅能证明其代表的事件序列，而且也能证明它本身是由最强 CPU \textbf{算力（power）}\ 池产生的。只要不会联合攻击网络的节点控制了 \textbf{占多数（majority）}\ 的 CPU \textbf{算力}，这些节点将会生成最长的链并超过攻击者。这种网络只需极简的架构。信息将被尽最大努力广播，节点可以随时离开和重新加入网络，重新加入时需接受当前最长 \textbf{工作量证明}\ 链作为它们离开时交易的证明。
\end{abstract}

\section{简介}
互联网贸易已经变得几乎完全依赖金融机构作为可信第三方来处理电子支付。尽管对于大部分交易这种系统运行得足够好，但仍有 \textbf{基于信任模型（trust based model）}\ 这个固有缺点。因为金融机构不可避免的需要调解争端，完全的 \textbf{不可撤销（non-reversible）}\ 交易实际是做不到的。调解成本增加了交易成本，限制了最小实际交易额度使日常小额交易成为不可能，并且由于缺乏不可撤销支付的能力，对不可撤销服务进行支付将需要更大的交易成本。由于存在交易撤销的可能性，因此需要更加广泛的信任前提。商家必须提防他们的客户，麻烦他们提供更多他本不必要的信息。一定比例的欺诈被认为是不可避免的。虽然使用实物货币可避免交易成本以及交易的不确定性，但是不存在不引入一个信任方而能在通信通道上进行支付的机制。

其实我们需要的是一个基于 \textbf{密码学原理（cryptographic proof）}\ 而不是基于信任的电子支付系统，该系统允许任何有交易意愿的双方能直接交易而不需要一个可信第三方。计算上不可撤销的交易将保护卖家不被欺诈，用来保护买家的 \textbf{程序化合约机制（routine escrow mechanisms）}\ 也应该较容易实现。在这篇论文中，我们提出一种使用点对点分布式 \textbf{时间戳服务器（timestamp server）}\ 生成基于时间序列的交易计算证明来解决 \textbf{双重支付}\ 问题的方案。只要诚实节点集体控制的 CPU \textbf{算力}\ 大于任意合作的攻击节点群的 CPU \textbf{算力}，这个系统就是安全的。

\section{交易}
我们定义一枚 \textbf{电子货币（electronic coin）}\ 就是一条数字签名链。当前货币拥有者通过将上一次交易和下一个拥有者的 \textbf{公钥（public key）}\ 的哈希值的数字签名添加到此货币末尾的方式将这枚货币转移给下一个拥有者。收款人可以通过验证数字签名来证实其为该链的所有者。

![bitcoin-1.svg](images/bitcoin-1.svg)


这里的问题是收款人不能验证货币的拥有者没有对此货币进行 \textbf{双重支付}。通常的做法是引入一个可信任的中央机构或 \textbf{造币厂（mint）}\ 来检查每笔交易是否存在 \textbf{双重支付}。每笔交易之后，都需要将这枚电子货币退回造币厂以换取发行一枚新的货币，只有由造币厂直接发行的货币才能被确认没有被 \textbf{双重支付}。这个方案的问题在于整个货币系统的命运都依赖于运营造币厂的公司，每笔交易都需要经过它们，就像银行一样。

我们需要一种能让收款人知道上一个货币拥有者没有对任何更早的交易签名。对我们来说，最早的那次交易是唯一有效的，所以我们不需要关心本次交易后面的 \textbf{双重支付}\ 尝试。唯一能保证一笔交易不存在的方法法是知晓所有之前的交易。在造币厂模型中，造币厂知晓所有交易并确定哪笔交易最先到达。在不引入一个可信任方的前提下要达到这个目的，所有交易就必须 \textbf{公开发布（publicly announced）} \cite{Dai}，而且需要一个能让所有参与者达成交易顺序历史一致的系统。收款人在每笔交易时，都需要 \textbf{占多数}\ 的节点认同此交易是最先收到。

\section{时间戳服务器}
我们提出的方案从时间戳服务器开始。时间戳服务器计算包含数据项的 \textbf{区块（block）}\ 的哈希值来给其打时间戳并广泛的发布这个哈希值，就像在报纸或新闻组帖子里\cite{Massias,Haber,Bayer,Stornetta}。时间戳能证明要得到这些数据的哈希值，显然这些数据当时一定是存在的。每个时间戳的哈希值都纳入了上一个时间戳，形成一条链，后面的时间戳进一步证实前一个时间戳。

![bitcoin-2.svg](images/bitcoin-2.svg)

\section{工作量证明}
为了实现一个基于点对点的时间戳服务器，我们需要使用一个类似 Adam Back 提出的 \textbf{哈希现金（hashcash）}\cite{Back}\ 的 \textbf{工作量证明}\ 系统，而不是报纸或新闻组帖子那样。 \textbf{工作量证明}\ 采取查找一个数值，使得被哈希时，如使用 \textbf{SHA-256}，哈希值以数个 0 比特开始。平均所需工作量将随所需 0 比特位呈指数级增长，而对工作量验证却只需执行一次哈希就可以。

对于我们的时间戳网络。我们通过在 \textbf{区块}\ 中增加随机数直到使得 \textbf{区块}\ 的哈希值满足所需的 0 比特位的数被找到的方式实现 \textbf{工作量证明}。一旦 CPU 耗费了 \textbf{算力}\ 是 \textbf{工作量证明}\ 得到满足，那么除非重做这个工作就不能改变这个 \textbf{区块}。由于后面的 \textbf{区块}\ 是链接在这个 \textbf{区块}\ 后面的，改变这个 \textbf{区块}\ 就需要重做所有其后面的 \textbf{区块}\ 工作量。

![bitcoin-3.svg](images/bitcoin-3.svg)

\textbf{工作量证明}\ 同时解决了确定谁是代表 \textbf{占多数}\ 决定的问题。如果大多数是 \textbf{按 IP 地址投票（one-IP-address-one-vote）}\ 来决定，那么它将可能被能分配大量 IP 地址的人破坏。 \textbf{工作量证明}\ 本质上是 \textbf{按 CPU 投票（one-CPU-one-vote）}。最长的链代表了 \textbf{占多数}\ 决定，因为有最大量 \textbf{工作量证明}\ 的精力投入到这条链上。如果 \textbf{占多数}\ 的 CPU 算力被诚实节点控制，诚实的链就会增长的最快并超过其他的链。要修改过去的某区块，攻击者必须重做这个区块以及其后的所有区块的工作量证明从而赶上并超过诚实节点的工作。我们后面会证明随着后续的区块被添加一个更慢的攻击者赶上诚实节点的概率将呈指数级递减。

为了抵消硬件运算速度的增加及平衡不同时期运行节点的利益不一致，工作量证明的难度将由 \textbf{移动平均数（moving average）}\ 来得到每小时生成区块的平均数。如果区块生成得过块，那么生成的难度就会增加。

\section{网络}
网络按以下步骤运行：

\begin{enumerate}
 \item 新交易向所有节点广播。
 \item 每个节点将交易收集到一个区块。
 \item 每个节点为它的区块寻找工作量证明。
 \item 当一个节点找到了工作量证明，就向所有节点广播这个区块。
 \item 节点只有在区块内所有交易都是有效的且之前没有被支付的情况下接收这个区块。
 \item 节点通过使用某个区块的哈希值作为上一个哈希值在链中创建下一个区块的方式表示对这个区块的接受。
\end{enumerate}

节点总是认为最长的链为正确的并继续工作来延长它。如果两个节点同时广播了不同的下一个区块，有些节点可能先收到其中一个而其他节点先收到另一个。这种情况，节点基于他们收到的第一个区块工作，但是也保存另一个分支以防它变为更长的链。当下一个工作量证明被找到后僵局就会被打破从而其中一个分支变得更长；在另一个分支上工作的节点将切换到更长的链。

新交易的广播不必到达所有的节点。只要到达足够多节点，就会进入到一个区块。区块广播也是能容忍消息丢失的。如果一个节点没有收到某个区块，它将在收到下一个区块时发现它丢失了某个区块然后去请求这个区块。

\section{激励}
为了方便，区块中的第一笔交易是区块创建者开启一枚属于他的货币的特殊的交易。这就增加了对支持网络的节点的激励，并提供了一种分发货币到流通市场的方法，因为这里没有中央机构来发行货币。新货币稳定的增加就像黄金矿工消耗资源并增加黄金到流通市场一样。对我们而言，消耗的是 CPU 时间和电力。

激励也可以由交易费用提供。如果交易的 \textbf{输出值（output）}\ 小于其 \textbf{输入值（input）}\ ，差价就作为交易费被加到包含此交易的区块的激励。一旦预定量的货币进入了流通市场，激励将变为只含有交易费，这样可以完全地避免通胀。

激励有助于鼓励节点保持诚实。如果一个贪心的攻击者有能力聚集比所有诚实节点更多的 CPU 算力，他将面临选择以骗回已付款的方式欺诈别人，或选择使用这些算力生成新的货币。他将发现遵守系统规则对他更有利，这些规则将准许他获得比所有其他人更多的新货币，这比颠覆系统并使他自己在系统中财产失效更好。

\section{回收磁盘空间}
一旦某个货币的最新的交易已经纳入足够多的区块，这之前的交易就可以被丢弃以节省磁盘空间。为实现此功能而又不破坏区块的哈希值，交易将被哈希进 \textbf{默克尔树（Merkle Tree）} \cite{Merkle}\cite{Massias}\cite{Stornetta}，只有根节点被纳入到区块的哈希值。老的区块可通过剪除树枝的方式被压缩。树枝内部的哈希不需要被保存。

![bitcoin-4.svg](images/bitcoin-4.svg)

每个不包含交易的区块头大约是 80 字节。如果每十分钟生成一个区块，每年生成 \textbf{80 bytes * 6 * 24 * 365 = 4.2 MB}，2008 年在售的典型计算机有 2 GB 内存，并且 \textbf{摩尔定律（Moore's Law）}\ 预测目前每年内存增加 1.2 GB，所以就算区块头要存在内存里也不是问题。

\section{简化的支付验证}
不运行一个完整的网络节点也是可以进行支付验证的。用户只需拥有一个最长工作量证明链的区块头副本，他可以通过向其他网络节点查询以确认他拥有了最长的链，并获取链接交易到给交易打时间戳区块的默克尔分支。虽然他自己不能确认这个交易，但如果交易已经链接到到链中的某个位置，就能说明网络已经接受了此交易，而其后追加的区块也对此进行了进一步确认。

![bitcoin-5.svg](images/bitcoin-5.svg)

同样地，只要诚实节点控制着网络这种简化验证就是可靠的，如果网络被攻击者控制简化验证会变得比较脆弱。虽然网络节点可以自己验证交易，但只要攻击者持续控制网络那么这种简化的方法就可能被攻击者的伪造交易欺骗。一种对策是让网络节点发现一个无效的区块时发出警告，提醒用户软件下载整个区块和被警告的交易来检查不一致性。为了自主的安全性以及更快的支付确认，收款频繁的公司也可以运行他们自己的节点。

\section{合并和分割币值}
尽管单个的处理每个货币是可能的，将一次转账按每一分拆成多次交易将是笨拙的。为允许币值被拆分和合并，交易包含多个输入值和输出值。通常是一个从之前交易而得的较大输入值或多个较小输入值的组合，以及最多两个输出值：一个作为支付，另一个作为找零，如果有的话，退还给支付发起者。

![bitcoin-6.svg](images/bitcoin-6.svg)

注意这里的 \textbf{扇出（fan-out）}，即一笔交易依赖数笔交易，这数笔交易又依赖更多的交易，在这里是不存在问题的。永远不需要获取每笔独立交易的完整历史副本。

\section{隐私}
传统的银行模型通过限制参与方和可信第三方对信息的访问来达到一定程度的隐私。交易必须要公开发布不能使用这个方法，但隐私仍可在其他地方通过阻断信息流的方式来保护：那就是保持公钥匿名。公众能看到有人正在发送一定量的货币给其他人，但是不能将交易关联到某个人。这和证券交易所发布的信息级别类似，每笔交易的时间和交易量，即行情是公开的，但是不会显示交易双方是谁。

![bitcoin-7.svg](images/bitcoin-7.svg)

作为额外的防火墙，对每笔交易使用新密钥可以防止他们被关联到一个共同的拥有者。由于多输入值交易存在，有些关联仍不可避免，因为多输入值交易必然暴露其多个输入是属于同一个拥有者的。风险就在于如果一个密钥的拥有者被暴露，关联性将暴露其他属于同一个拥有者的交易。

\section{计算}

我们考察一个攻击者试图生成一条比诚实链更快的链的情况。即使这个目标达到了，也不会使系统变得可以任意修改，比如凭空创建货币或拿走不属于他的钱。节点将不会接受无效的交易作为支付，而且诚实节点永远不会接受一个包含无效交易的区块。攻击者只可能改变他自己的某笔交易来拿回他已经支出的钱。

诚实链与攻击者的链之间的竞争可以描述为 \textbf{二项随机漫步（Binomial Random Walk）}。成功事件是诚实节点被延长一个区块，两条链的差距加 1，失败事件是攻击者的链延长一个区块，两条链的差距减 1。

攻击者从某一落后位置赶上诚实链的概率类似于 \textbf{赌徒破产理论（Gambler's Ruin problem）}。设想一个拥有无限信用的赌徒从一定亏损开始，进行无限次的赌博试图达到盈亏平衡。我们可以计算他达到盈亏平衡，即一个攻击者赶上诚实链的概率，如下\cite{Feller}：

\begin{align*}
  & p = \text{诚实节点找到下一个区块的概率}            \\
  & q_z = \text{攻击者从落后 z 个区块赶上诚实链的概率} \\
  & q = \text{攻击者找到下一个区块的概率}              \\
  & q_z =                                              
 \begin{Bmatrix}
  1         & if \ p \leq q \\
  (q / p)^z & if \ p > q    
 \end{Bmatrix}
\end{align*}


我们假设 $p > q$，概率将随着攻击者需要赶上的区块数增加而呈指数下降。由于赔率的原因，如果他没有在开始幸运的赶上，他落得越远赶上的概率就越渺茫。

我们现在考察一个新交易的收款人要等多久才能确保付款人不能再改变这个交易。我们假设付款人是想让收款人相信他暂时已经付款，然后在一段时间后换成支付回他自己。这时收款人会收到警告，但付款人希望警告已为时已晚。

收款人生成一个新密钥对将公钥给付款人，这样付款人就无法提前对交易签名。这能防止付款人通过预先准备一条区块链并持续工作直到他足够幸运获得摇摇领先，这时执行交易。一旦交易被发出，不诚实的付款人开始秘密地在一条包含了他的不同版本交易的另一个平行链上工作。

收款人等到交易被加到区块中且其后增加了 $z$ 个区块。他不知道攻击者确切的进度，但是假设诚实的块按期望的平均时间生成区块，攻击者潜在进度将是一个 \textbf{泊松分布（Poisson distribution）}，其期望值为：

\begin{align*}
 \lambda = z\frac{q}{p}
\end{align*}

为计算攻击者现在仍然能赶上的概率，我们给每个他可能达到的进度的 \textbf{泊松密度（Poisson density）}\ 乘以他在那个进度能赶上诚实链的概率：

\begin{align*}
 \sum_{k = 0}^{\infty}
 \frac{\lambda^ke^{-\lambda}}{k!}
 \cdot
 \begin{Bmatrix}
  (q / p)^z & if \ k \leq z \\
  1         & if \ k > z    
 \end{Bmatrix}
\end{align*}

变换以避免对分布的无限尾部求和...

\begin{align*}
 1-
 \sum_{k = 0}^{z}
 \frac{\lambda^ke^{-\lambda}}{k!}
 \big(1 - (q / p)^{(z - k)}\big)
\end{align*}

转换成 C 语言代码...

\begin{lstlisting}[language=C]
#include <math.h>
double AttackerSuccessProbability(double q, int z) {
  double p = 1.0 - q;
  double lambda = z * (q / p);
  double sum = 1.0;
  int i, k;
  for (k = 0; k <= z; k++) {
    double poisson = exp(-lambda);
    for (i = 1; i <= k; i++)
    poisson *= lambda / i;
    sum -= poisson * (1 - pow(q / p, z - k));
  }
  return sum;
}
\end{lstlisting}

一些运行结果如下，我们可以看到概率随 $z$ 呈指数下降。

\begin{lstlisting}
q=0.1
z=0    P=1.0000000
z=1    P=0.2045873
z=2    P=0.0509779
z=3    P=0.0131722
z=4    P=0.0034552
z=5    P=0.0009137
z=6    P=0.0002428
z=7    P=0.0000647
z=8    P=0.0000173
z=9    P=0.0000046
z=10   P=0.0000012
\end{lstlisting}

\begin{lstlisting}
q=0.3
z=0    P=1.0000000
z=5    P=0.1773523
z=10   P=0.0416605
z=15   P=0.0101008
z=20   P=0.0024804
z=25   P=0.0006132
z=30   P=0.0001522
z=35   P=0.0000379
z=40   P=0.0000095
z=45   P=0.0000024
z=50   P=0.0000006
\end{lstlisting}

P 小于 0.1\% 的解...
\begin{lstlisting}
P < 0.001
q=0.10   z=5
q=0.15   z=8
q=0.20   z=11
q=0.25   z=15
q=0.30   z=24
q=0.35   z=41
q=0.40   z=89
q=0.45   z=340
\end{lstlisting}

\section{总结}

我们提出了一种不依赖信任的电子交易系统。我们从通用的数字签名货币体系开始，这体系提供了强有力的所有权控制，当时缺乏防止双重支付的方法。未解决这个问题，我们提出一种使用工作量证明来记录公共交易历史的点对点网络，只有诚实节点控制了占多数的 CPU 算力，交易历史将很快变得对攻击者在计算上不可更改。网络将因其简洁性而健壮。节点只需很少的协调就能同时工作。它们不需要被认证，因为信息不会被发送到某个特殊的位置，只需被尽最大努力传播。节点可以随时离开和重新加入网络，重新加入时需接受当前最长链作为它们离开时交易的证明。节点使用 CPU 算力来投票，通过延长有效区块来表达对其接受，通过拒绝延长无效区块来表达对其抵制。任何需要的规则和激励都可通过这个共识机制来加强。


%++++++++++++++++++++++++++++++++++++++++
% References section will be created automatically
% with inclusion of "thebibliography" environment
% as it shown below. See text starting with line
% \begin{thebibliography}{99}
% Note: with this approach it is YOUR responsibility to put them in order
% of appearance.

\begin{thebibliography}{99}
 
 \bibitem{Dai}
 W. Dai, "b-money," \url{http://www.weidai.com/bmoney.txt}, 1998.
 
 \bibitem{Massias}
 H. Massias, X.S. Avila, and J.-J. Quisquater, "Design of a secure timestamping service with minimal trust requirements," In \textit{20th Symposium on Information Theory in the Benelux}, May 1999.
 
 \bibitem{Haber}
 S. Haber, W.S. Stornetta, "How to time-stamp a digital document," In \textit{Journal of Cryptology}, vol 3, no 2, pages 99-111, 1991.
 
 \bibitem{Bayer}
 D. Bayer, S. Haber, W.S. Stornetta, "Improving the efficiency and reliability of digital time-stamping," In \textit{Sequences II: Methods in Communication, Security and Computer Science}, pages 329-334, 1993.
 
 \bibitem{Stornetta}
 S. Haber, W.S. Stornetta, "Secure names for bit-strings," In \textit{Proceedings of the 4th ACM Conference on Computer and Communications Security}, pages 28-35, April 1997.
 
 \bibitem{Back}
 A. Back, "Hashcash - a denial of service counter-measure," \url{http://www.hashcash.org/papers/hashcash.pdf}, 2002.
 
 \bibitem{Merkle}
 R.C. Merkle, "Protocols for public key cryptosystems," In \textit{Proc. 1980 Symposium on Security and Privacy}, IEEE Computer Society, pages 122-133, April 1980.
 
 \bibitem{Feller}
 W. Feller, "An introduction to probability theory and its applications," 1957.
 
\end{thebibliography}

\end{document}
